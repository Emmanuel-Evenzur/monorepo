// Copyright 2021 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package com.google.devtools.build.lib.bazel.bzlmod;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.devtools.build.lib.analysis.BlazeDirectories;
import com.google.devtools.build.lib.cmdline.PackageIdentifier;
import com.google.devtools.build.lib.cmdline.RepositoryMapping;
import com.google.devtools.build.lib.cmdline.RepositoryName;
import com.google.devtools.build.lib.cmdline.StarlarkThreadContext;
import com.google.devtools.build.lib.events.ExtendedEventHandler;
import com.google.devtools.build.lib.packages.NoSuchPackageException;
import com.google.devtools.build.lib.packages.Rule;
import com.google.devtools.build.lib.packages.RuleClass;
import com.google.devtools.build.lib.packages.RuleFactory.InvalidRuleException;
import com.google.devtools.build.lib.packages.StarlarkNativeModule.ExistingRulesShouldBeNoOp;
import java.util.LinkedHashMap;
import java.util.Map;
import javax.annotation.Nullable;
import net.starlark.java.eval.Dict;
import net.starlark.java.eval.EvalException;
import net.starlark.java.eval.Starlark;
import net.starlark.java.eval.StarlarkSemantics;
import net.starlark.java.eval.StarlarkThread;
import net.starlark.java.syntax.Location;

/**
 * A context object that should be stored in a {@link StarlarkThread} for use during module
 * extension evaluation.
 */
public final class ModuleExtensionEvalStarlarkThreadContext extends StarlarkThreadContext {
  @Override
  public void storeInThread(StarlarkThread thread) {
    super.storeInThread(thread);
    // The following is just a hack; see documentation there for an explanation.
    thread.setThreadLocal(ExistingRulesShouldBeNoOp.class, new ExistingRulesShouldBeNoOp());
  }

  @Nullable
  public static ModuleExtensionEvalStarlarkThreadContext fromOrNull(StarlarkThread thread) {
    StarlarkThreadContext ctx = thread.getThreadLocal(StarlarkThreadContext.class);
    return ctx instanceof ModuleExtensionEvalStarlarkThreadContext c ? c : null;
  }

  record RepoDeclaration(
      RuleClass ruleClass,
      Map<String, Object> attrs,
      Location location,
      ImmutableList<StarlarkThread.CallStackEntry> callStack) {}

  private final String repoPrefix;
  private final PackageIdentifier basePackageId;
  private final RepositoryMapping repoMapping;
  private final BlazeDirectories directories;
  private final ExtendedEventHandler eventHandler;
  private final Map<String, RepoDeclaration> deferredRepos = new LinkedHashMap<>();

  public ModuleExtensionEvalStarlarkThreadContext(
      String repoPrefix,
      PackageIdentifier basePackageId,
      RepositoryMapping repoMapping,
      RepositoryMapping mainRepoMapping,
      BlazeDirectories directories,
      ExtendedEventHandler eventHandler) {
    super(() -> mainRepoMapping);
    this.repoPrefix = repoPrefix;
    this.basePackageId = basePackageId;
    this.repoMapping = repoMapping;
    this.directories = directories;
    this.eventHandler = eventHandler;
  }

  public void lazilyCreateRepos(
      StarlarkThread thread, Dict<String, Object> kwargs, RuleClass ruleClass)
      throws EvalException {
    Object nameValue = kwargs.getOrDefault("name", Starlark.NONE);
    if (!(nameValue instanceof String name)) {
      throw Starlark.errorf(
          "expected string for attribute 'name', got '%s'", Starlark.type(nameValue));
    }
    RepositoryName.validateUserProvidedRepoName(name);
    RepoDeclaration conflict = deferredRepos.get(name);
    if (conflict != null) {
      throw Starlark.errorf(
          "A repo named %s is already generated by this module extension at %s",
          name, conflict.location());
    }
    String prefixedName = repoPrefix + name;
    deferredRepos.put(
        name,
        new RepoDeclaration(
            ruleClass,
            Maps.transformEntries(kwargs, (k, v) -> k.equals("name") ? prefixedName : v),
            thread.getCallerLocation(),
            thread.getCallStack()));
  }

  /**
   * Returns the repos generated by the extension so far. The key is the "internal name" (as
   * specified by the extension) of the repo, and the value is the package containing (only) the
   * repo rule.
   */
  public ImmutableMap<String, RepoSpec> createAndGetRepos(StarlarkSemantics starlarkSemantics)
      throws EvalException, InterruptedException {
    ImmutableMap.Builder<String, RepoSpec> repoSpecs = ImmutableMap.builder();
    for (var entry : deferredRepos.entrySet()) {
      String name = entry.getKey();
      RepoDeclaration repo = entry.getValue();
      try {
        Rule rule =
            BzlmodRepoRuleCreator.createRule(
                basePackageId,
                repoMapping,
                directories,
                starlarkSemantics,
                eventHandler,
                repo.callStack,
                repo.ruleClass,
                repo.attrs);

        Map<String, Object> attributes =
            Maps.filterKeys(
                Maps.transformEntries(repo.attrs, (k, v) -> rule.getAttr(k)),
                k -> !k.equals("name"));
        String bzlFile =
            repo.ruleClass.getRuleDefinitionEnvironmentLabel().getUnambiguousCanonicalForm();
        var attributesValue = AttributeValues.create(attributes);
        AttributeValues.validateAttrs(
            attributesValue, String.format("%s '%s'", rule.getRuleClass(), name));
        RepoSpec repoSpec =
            RepoSpec.builder()
                .setBzlFile(bzlFile)
                .setRuleClassName(repo.ruleClass.getName())
                .setAttributes(attributesValue)
                .build();
        repoSpecs.put(name, repoSpec);
      } catch (InvalidRuleException | NoSuchPackageException e) {
        throw new EvalException(e, repo.callStack);
      }
    }
    return repoSpecs.buildOrThrow();
  }
}
