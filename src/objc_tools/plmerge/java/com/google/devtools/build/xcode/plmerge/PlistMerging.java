// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.devtools.build.xcode.plmerge;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.devtools.build.xcode.common.Platform;
import com.google.devtools.build.xcode.common.TargetDeviceFamily;
import com.google.devtools.build.xcode.util.Intersection;
import com.google.devtools.build.xcode.util.Mapping;
import com.google.devtools.build.xcode.util.Value;

import com.dd.plist.BinaryPropertyListWriter;
import com.dd.plist.NSArray;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.PropertyListParser;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Utility code for merging project files.
 */
public class PlistMerging extends Value<PlistMerging> {
  private final NSDictionary merged;

  @VisibleForTesting
  PlistMerging(NSDictionary merged) {
    super(merged);
    this.merged = merged;
  }

  /**
   * Merges several plist files into a single {@code NSDictionary}. Each file should be a plist (of
   * one of these formats: ASCII, Binary, or XML) that contains an NSDictionary.
   */
  @VisibleForTesting
  static NSDictionary merge(Iterable<? extends Path> sourceFilePaths) throws IOException {
    NSDictionary result = new NSDictionary();
    for (Path sourceFilePath : sourceFilePaths) {
      result.putAll(readPlistFile(sourceFilePath));
    }
    return result;
  }

  @VisibleForTesting
  public static NSDictionary readPlistFile(Path sourceFilePath) throws IOException {
    try (InputStream in = Files.newInputStream(sourceFilePath)) {
      NSObject sourceObject;
      try {
        sourceObject = PropertyListParser.parse(in);
      } catch (IOException | RuntimeException e) {
        throw e;
      } catch (Exception e) {
        // This is horrible, but necessary because PropertyListParser.parse throws Exception
        throw new RuntimeException(e);
      }
      if (!(sourceObject instanceof NSDictionary)) {
        throw new IOException(String.format("%s stores a %s but expected an NSDictionary",
            sourceFilePath, sourceObject.getClass()));
      }
      return (NSDictionary) sourceObject;
    }
  }

  /**
   * Writes the results of a merge operation to a plist file.
   * @param plistPath the path of the plist to write in binary format
   */
  public void writePlist(Path plistPath) throws IOException {
    try (OutputStream out = Files.newOutputStream(plistPath)) {
      BinaryPropertyListWriter.write(out, merged);
    }
  }

  /**
   * Writes a PkgInfo file based on certain keys in the merged plist.
   * @param pkgInfoPath the path of the PkgInfo file to write. In many iOS apps, this file just
   *     contains the raw string {@code APPL????}.
   */
  public void writePkgInfo(Path pkgInfoPath) throws IOException {
    String pkgInfo =
        Mapping.of(merged, "CFBundlePackageType").or(NSObject.wrap("APPL")).toString()
        + Mapping.of(merged, "CFBundleSignature").or(NSObject.wrap("????")).toString();
    Files.write(pkgInfoPath, pkgInfo.getBytes(StandardCharsets.UTF_8));
  }

  /** Invokes {@link #writePlist(Path)} and {@link #writePkgInfo(Path)}. */
  public void write(Path plistPath, Path pkgInfoPath) throws IOException {
    writePlist(plistPath);
    writePkgInfo(pkgInfoPath);
  }

  /**
   * Returns a map containing entries that should be added to the merged plist. These are usually
   * generated by Xcode automatically during the build process.
   */
  public static Map<String, NSObject> automaticEntries(
      Iterable<TargetDeviceFamily> targetedDeviceFamily, Platform platform, String sdkVersion,
      String minimumOsVersion) {
    ImmutableMap.Builder<String, NSObject> result = new ImmutableMap.Builder<>();
    List<Integer> uiDeviceFamily =
        Mapping.of(
            TargetDeviceFamily.UI_DEVICE_FAMILY_VALUES,
            ImmutableSet.copyOf(targetedDeviceFamily))
        .get();
    result.put("UIDeviceFamily", NSObject.wrap(uiDeviceFamily.toArray()));
    result.put("DTPlatformName", NSObject.wrap(platform.getLowerCaseNameInPlist()));
    result.put("DTSDKName", NSObject.wrap(platform.getLowerCaseNameInPlist() + sdkVersion));
    result.put("CFBundleSupportedPlatforms", new NSArray(NSObject.wrap(platform.getNameInPlist())));

    if (platform == Platform.DEVICE) {
      // TODO(bazel-team): Figure out if there are more appropriate values to put here, or if any
      // can be omitted. These have been copied from a plist file generated by Xcode for a device
      // build.
      result.put("DTCompiler", NSObject.wrap("com.apple.compilers.llvm.clang.1_0"));
      result.put("BuildMachineOSBuild", NSObject.wrap("13D65"));
      result.put("DTPlatformBuild", NSObject.wrap("11B508"));
      result.put("DTSDKBuild", NSObject.wrap("11B508"));
      result.put("DTXcode", NSObject.wrap("0502"));
      result.put("DTXcodeBuild", NSObject.wrap("5A3005"));
      result.put("DTPlatformVersion", NSObject.wrap(sdkVersion));
      result.put("MinimumOSVersion", NSObject.wrap(minimumOsVersion));
    }
    return result.build();
  }

  /**
   * Generates final merged Plist file and PkgInfo file in the specified locations, and includes the
   * "automatic" entries in the Plist.
   */
  public static PlistMerging from(List<Path> sourceFiles, Map<String, NSObject> automaticEntries,
      Map<String, String> substitutions) throws IOException {
    NSDictionary merged = PlistMerging.merge(sourceFiles);

    Set<String> conflictingEntries = Intersection.of(automaticEntries.keySet(), merged.keySet());
    Preconditions.checkArgument(conflictingEntries.isEmpty(),
        "The following plist entries are generated automatically, but are present in one of the "
        + "input lists: %s", conflictingEntries);
    merged.putAll(automaticEntries);

    for (String key : merged.keySet()) {
      NSObject entry = merged.get(key);
      if (entry.toJavaObject() instanceof String) {
        String newValue = substituteEnvironmentVariable(
            substitutions, (String) entry.toJavaObject());
        merged.put(key, newValue);
      }
    }

    return new PlistMerging(merged);
  }

  private static String substituteEnvironmentVariable(
      Map<String, String> substitutions, String string) {
    // The substitution is *not* performed recursively.
    for (String variableName : substitutions.keySet()) {
      string = string
          .replace("${" + variableName + "}", substitutions.get(variableName))
          .replace("$(" + variableName + ")", substitutions.get(variableName));
    }

    return string;
  }
}
